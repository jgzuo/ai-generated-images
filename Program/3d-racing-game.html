<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dèµ›è½¦æ¸¸æˆ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #1a1a2e;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* ä¸»èœå• */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #main-menu h1 {
            color: #ff6b6b;
            font-size: 64px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff6b6b;
        }

        #main-menu p {
            color: #ffffff;
            font-size: 18px;
            margin-bottom: 40px;
        }

        .menu-btn {
            padding: 20px 60px;
            font-size: 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }

        .menu-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.8);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            font-size: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            min-width: 250px;
        }

        #hud div {
            margin: 10px 0;
        }

        #hud .label {
            color: #888;
            font-size: 14px;
        }

        #hud .value {
            color: #00ff88;
            font-size: 28px;
            font-weight: bold;
        }

        /* å°åœ°å›¾ */
        #minimap-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 50;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
        }

        #minimap {
            width: 200px;
            height: 200px;
            background: #222;
            border: 2px solid #444;
        }

        /* æš‚åœç•Œé¢ */
        #pause-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            z-index: 100;
            display: none;
            text-align: center;
        }

        #pause-menu h2 {
            color: #ff6b6b;
            font-size: 48px;
            margin-bottom: 30px;
        }

        /* æ¸¸æˆç»“æŸç•Œé¢ */
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            z-index: 100;
            display: none;
            text-align: center;
        }

        #game-over h2 {
            color: #ff6b6b;
            font-size: 48px;
            margin-bottom: 20px;
        }

        #game-over .result {
            color: #ffffff;
            font-size: 24px;
            margin: 15px 0;
        }

        #game-over .score {
            color: #00ff88;
            font-size: 36px;
            margin: 20px 0;
        }

        /* æ§åˆ¶è¯´æ˜ */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            z-index: 50;
        }

        #controls p {
            margin: 5px 0;
        }

        kbd {
            background: #444;
            padding: 2px 8px;
            border-radius: 4px;
            border: 1px solid #666;
            font-family: monospace;
        }

        /* éšè—ç±» */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <!-- ä¸»èœå• -->
        <div id="main-menu">
            <h1>ğŸï¸ 3Dèµ›è½¦æ¸¸æˆ</h1>
            <p>ä½“éªŒçœŸå®çš„3Dèµ›è½¦ç«é€Ÿï¼</p>
            <button class="menu-btn" onclick="startGame()">å¼€å§‹æ¸¸æˆ</button>
        </div>

        <!-- HUD -->
        <div id="hud" class="hidden">
            <div>
                <div class="label">é€Ÿåº¦</div>
                <div class="value" id="speed">0 km/h</div>
            </div>
            <div>
                <div class="label">æ—¶é—´</div>
                <div class="value" id="time">00:00.00</div>
            </div>
            <div>
                <div class="label">åœˆæ•°</div>
                <div class="value" id="lap">1 / 3</div>
            </div>
            <div>
                <div class="label">æ’å</div>
                <div class="value" id="position">1st</div>
            </div>
            <div>
                <div class="label">åˆ†æ•°</div>
                <div class="value" id="score">0</div>
            </div>
        </div>

        <!-- å°åœ°å›¾ -->
        <div id="minimap-container" class="hidden">
            <canvas id="minimap" width="200" height="200"></canvas>
        </div>

        <!-- æš‚åœèœå• -->
        <div id="pause-menu">
            <h2>æš‚åœ</h2>
            <button class="menu-btn" onclick="resumeGame()">ç»§ç»­æ¸¸æˆ</button>
            <button class="menu-btn" onclick="quitToMenu()">è¿”å›èœå•</button>
        </div>

        <!-- æ¸¸æˆç»“æŸ -->
        <div id="game-over">
            <h2>æ¯”èµ›ç»“æŸï¼</h2>
            <div class="result">æœ€ç»ˆæ’å: <span id="final-position">1st</span></div>
            <div class="result">ç”¨æ—¶: <span id="final-time">00:00.00</span></div>
            <div class="score">å¾—åˆ†: <span id="final-score">0</span></div>
            <div class="result" id="best-record" style="color: #ffd700;"></div>
            <button class="menu-btn" onclick="restartGame()">å†æ¥ä¸€å±€</button>
            <button class="menu-btn" onclick="quitToMenu()">è¿”å›èœå•</button>
        </div>

        <!-- æ§åˆ¶è¯´æ˜ -->
        <div id="controls" class="hidden">
            <p><kbd>â†‘</kbd> / <kbd>W</kbd> åŠ é€Ÿ</p>
            <p><kbd>â†“</kbd> / <kbd>S</kbd> åˆ¹è½¦</p>
            <p><kbd>â†</kbd> / <kbd>A</kbd> å·¦è½¬</p>
            <p><kbd>â†’</kbd> / <kbd>D</kbd> å³è½¬</p>
            <p><kbd>Space</kbd> æ‰‹åˆ¹</p>
            <p><kbd>P</kbd> æš‚åœ</p>
        </div>
    </div>

    <script>
        // ==================== é…ç½®å¸¸é‡ ====================
        const GAME_CONFIG = {
            TRACK_WIDTH: 30,
            TRACK_LENGTH: 1000,
            LANES: 4,
            LANE_WIDTH: 7.5,
            MAX_SPEED: 150,
            ACCELERATION: 50,
            BRAKE_POWER: 80,
            TURN_SPEED: 2.5,
            FRICTION: 0.98,
            TOTAL_LAPS: 3,
            AI_COUNT: 5,
            MAX_PARTICLES: 5000,
            OBSTACLE_INTERVAL: 100,
        };

        // ==================== æ¸¸æˆçŠ¶æ€ ====================
        const gameState = {
            mode: 'menu', // menu, racing, paused, gameover
            currentTime: 0,
            currentLap: 1,
            position: 1,
            score: 0,
            bestTime: Infinity,
            bestScore: 0,
            totalRaces: 0
        };

        // ==================== Three.js å˜é‡ ====================
        let scene, camera, renderer;
        let clock = new THREE.Clock();

        // ==================== æ¸¸æˆå¯¹è±¡ ====================
        let playerCar;
        let aiOpponents = [];
        let trackGenerator;
        let particleSystem;
        let collisionDetection;
        let saveSystem;

        // ==================== è¾“å…¥çŠ¶æ€ ====================
        const inputState = {
            throttle: false,
            brake: false,
            steering: 0,
            handbrake: false
        };

        // ==================== ç‰©ç†å¼•æ“ç±» ====================
        class CarPhysics {
            constructor() {
                this.velocity = 0;
                this.acceleration = 0;
                this.maxSpeed = GAME_CONFIG.MAX_SPEED;
                this.friction = GAME_CONFIG.FRICTION;
                this.turnSpeed = 0;
                this.driftFactor = 0;
            }

            update(deltaTime, input) {
                // åŠ é€Ÿè®¡ç®—
                if (input.throttle) {
                    this.acceleration = GAME_CONFIG.ACCELERATION;
                } else if (input.brake) {
                    this.acceleration = -GAME_CONFIG.BRAKE_POWER;
                } else {
                    this.acceleration = 0;
                }

                // é€Ÿåº¦æ›´æ–°
                this.velocity += this.acceleration * deltaTime;
                this.velocity *= this.friction;
                this.velocity = Math.max(0, Math.min(this.velocity, this.maxSpeed));

                // è½¬å‘è®¡ç®—
                if (this.velocity > 1) {
                    const turnMultiplier = 1 - (this.velocity / this.maxSpeed) * 0.5;
                    this.turnSpeed = input.steering * GAME_CONFIG.TURN_SPEED * turnMultiplier;
                } else {
                    this.turnSpeed = 0;
                }

                // æ¼‚ç§»è®¡ç®—
                if (input.handbrake && this.velocity > 50) {
                    this.driftFactor = 0.8;
                } else {
                    this.driftFactor = this.lerp(this.driftFactor, 0, 0.1);
                }
            }

            lerp(start, end, t) {
                return start + (end - start) * t;
            }
        }

        // ==================== è½¦è¾†ç±» ====================
        class Car {
            constructor(color, isPlayer = false) {
                this.mesh = new THREE.Group();
                this.velocity = new THREE.Vector3();
                this.position = new THREE.Vector3();
                this.rotation = new THREE.Vector3();
                this.physics = new CarPhysics();
                this.isPlayer = isPlayer;
                this.lane = 0;
                this.targetLane = 0;
                this.width = 2;
                this.length = 4;

                this.createCarModel(color);
            }

            createCarModel(color) {
                // è½¦èº«
                const bodyGeo = new THREE.BoxGeometry(2, 0.8, 4);
                const bodyMat = new THREE.MeshPhongMaterial({
                    color: color,
                    shininess: 100
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.5;
                body.castShadow = true;
                this.mesh.add(body);

                // è½¦é¡¶
                const roofGeo = new THREE.BoxGeometry(1.6, 0.6, 2);
                const roofMat = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    shininess: 100
                });
                const roof = new THREE.Mesh(roofGeo, roofMat);
                roof.position.set(0, 1.1, -0.3);
                roof.castShadow = true;
                this.mesh.add(roof);

                // æŒ¡é£ç»ç’ƒ
                const windshieldGeo = new THREE.BoxGeometry(1.5, 0.5, 0.1);
                const glassMat = new THREE.MeshPhongMaterial({
                    color: 0x87CEEB,
                    transparent: true,
                    opacity: 0.6
                });
                const windshield = new THREE.Mesh(windshieldGeo, glassMat);
                windshield.position.set(0, 1.0, 0.7);
                windshield.rotation.x = -0.3;
                this.mesh.add(windshield);

                // è½¦è½®
                const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
                const wheelMat = new THREE.MeshPhongMaterial({
                    color: 0x222222,
                    shininess: 30
                });

                this.wheels = [];
                const wheelPositions = [
                    { x: -1, y: 0.4, z: 1.2 },
                    { x: 1, y: 0.4, z: 1.2 },
                    { x: -1, y: 0.4, z: -1.2 },
                    { x: 1, y: 0.4, z: -1.2 }
                ];

                wheelPositions.forEach(pos => {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.rotation.z = Math.PI / 2;
                    wheel.position.set(pos.x, pos.y, pos.z);
                    wheel.castShadow = true;
                    this.mesh.add(wheel);
                    this.wheels.push(wheel);
                });

                // è½¦ç¯
                const headlightGeo = new THREE.BoxGeometry(0.3, 0.2, 0.1);
                const headlightMat = new THREE.MeshBasicMaterial({
                    color: 0xffffcc
                });

                const leftLight = new THREE.Mesh(headlightGeo, headlightMat);
                leftLight.position.set(-0.6, 0.5, 2.0);
                this.mesh.add(leftLight);

                const rightLight = new THREE.Mesh(headlightGeo, headlightMat);
                rightLight.position.set(0.6, 0.5, 2.0);
                this.mesh.add(rightLight);

                // å°¾ç¯
                const taillightMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000
                });

                const leftTail = new THREE.Mesh(headlightGeo, taillightMat);
                leftTail.position.set(-0.6, 0.5, -2.0);
                this.mesh.add(leftTail);

                const rightTail = new THREE.Mesh(headlightGeo, taillightMat);
                rightTail.position.set(0.6, 0.5, -2.0);
                this.mesh.add(rightTail);
            }

            update(deltaTime) {
                this.physics.update(deltaTime, this.isPlayer ? inputState : this.aiInput);

                // æ›´æ–°ä½ç½®
                const moveSpeed = this.physics.velocity * deltaTime;
                this.position.z += moveSpeed;
                this.position.x += this.physics.turnSpeed * moveSpeed * 0.5;

                // é™åˆ¶åœ¨èµ›é“èŒƒå›´å†…
                const maxX = (GAME_CONFIG.LANES - 1) * GAME_CONFIG.LANE_WIDTH / 2;
                this.position.x = Math.max(-maxX, Math.min(maxX, this.position.x));

                // æ›´æ–°è½¦è½®æ—‹è½¬
                const wheelRotation = moveSpeed * 2;
                this.wheels.forEach(wheel => {
                    wheel.rotation.x += wheelRotation;
                });

                // æ›´æ–°ç½‘æ ¼ä½ç½®
                this.mesh.position.copy(this.position);
            }
        }

        // ==================== AIå¯¹æ‰‹ç±» ====================
        class AIOpponent extends Car {
            constructor(lane, difficulty) {
                const colors = [0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
                super(colors[lane % colors.length], false);

                this.lane = lane;
                this.difficulty = difficulty; // 0-1
                this.targetSpeed = 60 + Math.random() * 60;
                this.reactionTimer = 0;
                this.reactionTime = 0.5 + (1 - difficulty) * 0.5;
                this.aiInput = { throttle: false, brake: false, steering: 0, handbrake: false };

                // åˆå§‹ä½ç½®
                const laneX = (lane - 1.5) * GAME_CONFIG.LANE_WIDTH;
                this.position.set(laneX, 0, -10 - lane * 5);
                this.mesh.position.copy(this.position);
            }

            update(deltaTime, obstacles) {
                // é€Ÿåº¦æ§åˆ¶
                if (this.physics.velocity < this.targetSpeed) {
                    this.aiInput.throttle = true;
                    this.aiInput.brake = false;
                } else {
                    this.aiInput.throttle = false;
                    this.aiInput.brake = false;
                }

                // éšœç¢ç‰©æ£€æµ‹
                this.reactionTimer += deltaTime;
                if (this.reactionTimer >= this.reactionTime) {
                    this.reactionTimer = 0;
                    this.avoidObstacles(obstacles);
                }

                super.update(deltaTime);
            }

            avoidObstacles(obstacles) {
                // æ£€æµ‹å‰æ–¹éšœç¢ç‰©
                const obstaclesAhead = obstacles.filter(obs => {
                    const dist = obs.position.z - this.position.z;
                    return dist > 0 && dist < 50 && Math.abs(obs.position.x - this.position.x) < 5;
                });

                if (obstaclesAhead.length > 0) {
                    // å°è¯•æ¢é“
                    const currentLane = Math.round(this.position.x / GAME_CONFIG.LANE_WIDTH) + 1.5;
                    const availableLanes = [0, 1, 2, 3].filter(l => {
                        const laneX = (l - 1.5) * GAME_CONFIG.LANE_WIDTH;
                        return !obstaclesAhead.some(obs => Math.abs(obs.position.x - laneX) < 3);
                    });

                    if (availableLanes.length > 0 && Math.random() < this.difficulty) {
                        const bestLane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
                        const targetX = (bestLane - 1.5) * GAME_CONFIG.LANE_WIDTH;

                        if (targetX > this.position.x) {
                            this.aiInput.steering = 1;
                        } else if (targetX < this.position.x) {
                            this.aiInput.steering = -1;
                        }
                    } else {
                        // ç´§æ€¥åˆ¶åŠ¨
                        this.aiInput.brake = true;
                    }
                } else {
                    this.aiInput.steering = 0;
                    this.aiInput.brake = false;
                }
            }
        }

        // ==================== èµ›é“ç”Ÿæˆå™¨ç±» ====================
        class TrackGenerator {
            constructor() {
                this.segmentLength = 50;
                this.segments = [];
                this.obstacles = [];
                this.decorations = []; // æ·»åŠ è£…é¥°ç‰©æ•°ç»„
                this.mesh = new THREE.Group();

                this.generateInitialTrack();
            }

            generateInitialTrack() {
                // åˆ›å»ºåˆå§‹èµ›é“
                for (let i = 0; i < 20; i++) {
                    this.addSegment(i * this.segmentLength);
                }

                // åˆ›å»ºèµ›é“ç½‘æ ¼
                this.createTrackMesh();
            }

            addSegment(zPosition) {
                const segment = {
                    z: zPosition,
                    obstacles: []
                };

                // éšæœºæ·»åŠ éšœç¢ç‰©
                if (zPosition > 200 && Math.random() < 0.3) {
                    const lane = Math.floor(Math.random() * GAME_CONFIG.LANES);
                    const laneX = (lane - 1.5) * GAME_CONFIG.LANE_WIDTH;

                    const obstacle = this.createObstacle(laneX, zPosition);
                    segment.obstacles.push(obstacle);
                    this.obstacles.push(obstacle);
                }

                // æ·»åŠ è£…é¥°ç‰©
                this.addDecorations(zPosition);

                this.segments.push(segment);
            }

            createObstacle(x, z) {
                const type = Math.random() < 0.5 ? 'car' : 'barrier';
                const mesh = new THREE.Group();
                mesh.position.set(x, 0, z);

                if (type === 'car') {
                    // é™æ€è½¦è¾†éšœç¢ç‰©
                    const bodyGeo = new THREE.BoxGeometry(2, 0.8, 4);
                    const bodyMat = new THREE.MeshPhongMaterial({ color: 0x888888 });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    body.position.y = 0.5;
                    mesh.add(body);

                    const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 8);
                    const wheelMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
                    [[-1, 0.4, 1.2], [1, 0.4, 1.2], [-1, 0.4, -1.2], [1, 0.4, -1.2]].forEach(pos => {
                        const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(...pos);
                        mesh.add(wheel);
                    });
                } else {
                    // è·¯éšœ
                    const barrierGeo = new THREE.BoxGeometry(6, 1, 1);
                    const barrierMat = new THREE.MeshPhongMaterial({
                        color: 0xff4444,
                        shininess: 50
                    });
                    const barrier = new THREE.Mesh(barrierGeo, barrierMat);
                    barrier.position.y = 0.5;
                    mesh.add(barrier);
                }

                this.mesh.add(mesh);

                return {
                    type: type,
                    mesh: mesh,
                    position: mesh.position,
                    active: true
                };
            }

            // ==================== åˆ›å»ºè£…é¥°ç‰© ====================
            createTree(x, z) {
                const mesh = new THREE.Group();
                mesh.position.set(x, 0, z);

                // æ ‘å¹²
                const trunkHeight = 2 + Math.random() * 2;
                const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, trunkHeight, 8);
                const trunkMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                trunk.position.y = trunkHeight / 2;
                trunk.castShadow = true;
                mesh.add(trunk);

                // æ ‘å† ï¼ˆå¤šå±‚åœ†é”¥ï¼‰
                const foliageColors = [0x228B22, 0x006400, 0x32CD32];
                const foliageColor = foliageColors[Math.floor(Math.random() * foliageColors.length)];
                const foliageMat = new THREE.MeshPhongMaterial({ color: foliageColor });

                for (let i = 0; i < 3; i++) {
                    const size = 2.5 - i * 0.6;
                    const foliageGeo = new THREE.ConeGeometry(size, 2.5, 8);
                    const foliage = new THREE.Mesh(foliageGeo, foliageMat);
                    foliage.position.y = trunkHeight + 1.5 + i * 1.2;
                    foliage.castShadow = true;
                    mesh.add(foliage);
                }

                this.mesh.add(mesh);
                this.decorations.push({ mesh: mesh, position: mesh.position, type: 'tree' });
            }

            createBuilding(x, z) {
                const mesh = new THREE.Group();
                mesh.position.set(x, 0, z);

                const height = 10 + Math.random() * 30;
                const width = 5 + Math.random() * 10;
                const depth = 5 + Math.random() * 10;

                // å»ºç­‘ä¸»ä½“
                const buildingColors = [0x808080, 0xA9A9A9, 0x696969, 0x778899, 0xB0C4DE];
                const buildingMat = new THREE.MeshPhongMaterial({
                    color: buildingColors[Math.floor(Math.random() * buildingColors.length)]
                });
                const buildingGeo = new THREE.BoxGeometry(width, height, depth);
                const building = new THREE.Mesh(buildingGeo, buildingMat);
                building.position.y = height / 2;
                building.castShadow = true;
                mesh.add(building);

                // çª—æˆ·
                const windowMat = new THREE.MeshBasicMaterial({ color: 0xFFFFE0 });
                const windowGeo = new THREE.BoxGeometry(0.8, 1.2, 0.1);
                const floors = Math.floor(height / 3);
                const windowsPerFloor = Math.floor(width / 2);

                for (let floor = 0; floor < floors; floor++) {
                    for (let w = 0; w < windowsPerFloor; w++) {
                        const windowMesh = new THREE.Mesh(windowGeo, windowMat);
                        windowMesh.position.set(
                            -width / 2 + 1 + w * 2,
                            2 + floor * 3,
                            depth / 2 + 0.05
                        );
                        mesh.add(windowMesh);
                    }
                }

                this.mesh.add(mesh);
                this.decorations.push({ mesh: mesh, position: mesh.position, type: 'building' });
            }

            createPlant(x, z) {
                const mesh = new THREE.Group();
                mesh.position.set(x, 0, z);

                // çŒæœ¨ä¸›
                const plantMat = new THREE.MeshPhongMaterial({ color: 0x2E8B57 });
                const plantGeo = new THREE.SphereGeometry(1 + Math.random() * 0.5, 8, 6);
                const plant = new THREE.Mesh(plantGeo, plantMat);
                plant.position.y = 0.8;
                plant.scale.y = 0.7;
                plant.castShadow = true;
                mesh.add(plant);

                // æ·»åŠ ä¸€äº›å°èŠ±
                const flowerColors = [0xFF69B4, 0xFFD700, 0xFF4500, 0xDA70D6];
                for (let i = 0; i < 5; i++) {
                    const flowerMat = new THREE.MeshPhongMaterial({
                        color: flowerColors[Math.floor(Math.random() * flowerColors.length)]
                    });
                    const flowerGeo = new THREE.SphereGeometry(0.2, 6, 6);
                    const flower = new THREE.Mesh(flowerGeo, flowerMat);
                    flower.position.set(
                        (Math.random() - 0.5) * 1.5,
                        0.3,
                        (Math.random() - 0.5) * 1.5
                    );
                    mesh.add(flower);
                }

                this.mesh.add(mesh);
                this.decorations.push({ mesh: mesh, position: mesh.position, type: 'plant' });
            }

            createStreetLamp(x, z) {
                const mesh = new THREE.Group();
                mesh.position.set(x, 0, z);

                // ç¯æŸ±
                const poleHeight = 6;
                const poleGeo = new THREE.CylinderGeometry(0.1, 0.15, poleHeight, 8);
                const poleMat = new THREE.MeshPhongMaterial({ color: 0x2F4F4F });
                const pole = new THREE.Mesh(poleGeo, poleMat);
                pole.position.y = poleHeight / 2;
                pole.castShadow = true;
                mesh.add(pole);

                // ç¯ç½©
                const lampGeo = new THREE.SphereGeometry(0.4, 8, 6);
                const lampMat = new THREE.MeshBasicMaterial({ color: 0xFFFFAA });
                const lamp = new THREE.Mesh(lampGeo, lampMat);
                lamp.position.y = poleHeight;
                mesh.add(lamp);

                this.mesh.add(mesh);
                this.decorations.push({ mesh: mesh, position: mesh.position, type: 'lamp' });
            }

            createRock(x, z) {
                const mesh = new THREE.Group();
                mesh.position.set(x, 0, z);

                const rockMat = new THREE.MeshPhongMaterial({ color: 0x696969 });
                const rockGeo = new THREE.DodecahedronGeometry(0.8 + Math.random() * 0.5);
                const rock = new THREE.Mesh(rockGeo, rockMat);
                rock.position.y = 0.5;
                rock.rotation.set(Math.random(), Math.random(), Math.random());
                rock.castShadow = true;
                mesh.add(rock);

                this.mesh.add(mesh);
                this.decorations.push({ mesh: mesh, position: mesh.position, type: 'rock' });
            }

            // ==================== æ·»åŠ è£…é¥°ç‰©åˆ°èµ›é“ ====================
            addDecorations(zPosition) {
                // åœ¨èµ›é“ä¸¤ä¾§æ·»åŠ è£…é¥°ç‰©
                const leftSide = -GAME_CONFIG.TRACK_WIDTH / 2 - 8 - Math.random() * 15;
                const rightSide = GAME_CONFIG.TRACK_WIDTH / 2 + 8 + Math.random() * 15;

                // æ ¹æ®Zåæ ‡çš„å¥‡å¶æ€§æ¥å†³å®šæ”¾ç½®ä»€ä¹ˆè£…é¥°ç‰©
                const segmentNum = Math.floor(zPosition / this.segmentLength);
                const decorationType = segmentNum % 6;

                switch (decorationType) {
                    case 0: // æ ‘æœ¨
                        this.createTree(leftSide, zPosition);
                        if (Math.random() < 0.7) {
                            this.createTree(rightSide, zPosition + Math.random() * 10);
                        }
                        break;
                    case 1: // å»ºç­‘
                        this.createBuilding(leftSide - 5, zPosition);
                        if (Math.random() < 0.5) {
                            this.createBuilding(rightSide + 5, zPosition + Math.random() * 15);
                        }
                        break;
                    case 2: // æ¤ç‰©
                        this.createPlant(leftSide, zPosition);
                        this.createPlant(rightSide, zPosition + Math.random() * 8);
                        break;
                    case 3: // è·¯ç¯
                        this.createStreetLamp(leftSide, zPosition);
                        this.createStreetLamp(rightSide, zPosition);
                        break;
                    case 4: // æ ‘æœ¨å’Œæ¤ç‰©æ··åˆ
                        this.createTree(leftSide, zPosition);
                        this.createPlant(rightSide, zPosition + Math.random() * 10);
                        break;
                    case 5: // å²©çŸ³
                        this.createRock(leftSide, zPosition);
                        if (Math.random() < 0.6) {
                            this.createRock(rightSide, zPosition + Math.random() * 5);
                        }
                        break;
                }
            }

            createTrackMesh() {
                // åˆ›å»ºèµ›é“åœ°é¢
                const trackGeo = new THREE.PlaneGeometry(GAME_CONFIG.TRACK_WIDTH, 2000);
                const trackMat = new THREE.MeshPhongMaterial({
                    color: 0x333333,
                    shininess: 10
                });
                const track = new THREE.Mesh(trackGeo, trackMat);
                track.rotation.x = -Math.PI / 2;
                track.position.set(0, 0, 1000);
                track.receiveShadow = true;
                this.mesh.add(track);

                // åˆ›å»ºè½¦é“çº¿
                for (let i = 0; i < GAME_CONFIG.LANES - 1; i++) {
                    const x = (i - 0.5) * GAME_CONFIG.LANE_WIDTH;
                    const lineGeo = new THREE.PlaneGeometry(0.2, 2000);
                    const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                    const line = new THREE.Mesh(lineGeo, lineMat);
                    line.rotation.x = -Math.PI / 2;
                    line.position.set(x, 0.01, 1000);
                    this.mesh.add(line);
                }

                // åˆ›å»ºè‰åœ°
                const grassGeo = new THREE.PlaneGeometry(200, 2000);
                const grassMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
                const grassL = new THREE.Mesh(grassGeo, grassMat);
                grassL.rotation.x = -Math.PI / 2;
                grassL.position.set(-GAME_CONFIG.TRACK_WIDTH / 2 - 100, 0, 1000);
                this.mesh.add(grassL);

                const grassR = new THREE.Mesh(grassGeo, grassMat);
                grassR.rotation.x = -Math.PI / 2;
                grassR.position.set(GAME_CONFIG.TRACK_WIDTH / 2 + 100, 0, 1000);
                this.mesh.add(grassR);
            }

            update(playerZ) {
                // ç§»é™¤ç©å®¶åé¢çš„éšœç¢ç‰©
                this.obstacles = this.obstacles.filter(obs => {
                    if (obs.position.z < playerZ - 100) {
                        this.mesh.remove(obs.mesh);
                        return false;
                    }
                    return true;
                });

                // ç§»é™¤ç©å®¶åé¢çš„è£…é¥°ç‰©
                this.decorations = this.decorations.filter(dec => {
                    if (dec.position.z < playerZ - 150) {
                        this.mesh.remove(dec.mesh);
                        return false;
                    }
                    return true;
                });

                // ç”Ÿæˆæ–°èµ›é“æ®µ
                const lastSegment = this.segments[this.segments.length - 1];
                if (lastSegment && lastSegment.z < playerZ + 1000) {
                    this.addSegment(lastSegment.z + this.segmentLength);
                }

                // ç§»é™¤æ—§æ®µ
                this.segments = this.segments.filter(seg => seg.z > playerZ - 200);
            }

            getObstacles() {
                return this.obstacles.filter(obs => obs.active);
            }

            reset() {
                // æ¸…é™¤éšœç¢ç‰©
                this.obstacles.forEach(obs => this.mesh.remove(obs.mesh));
                this.obstacles = [];

                // æ¸…é™¤è£…é¥°ç‰©
                this.decorations.forEach(dec => this.mesh.remove(dec.mesh));
                this.decorations = [];

                this.segments = [];
                this.generateInitialTrack();
            }
        }

        // ==================== ç²’å­ç³»ç»Ÿç±» ====================
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            emit(type, position, count, color) {
                for (let i = 0; i < count; i++) {
                    const particle = {
                        position: position.clone(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            Math.random() * 3,
                            type === 'exhaust' ? -Math.random() * 10 : (Math.random() - 0.5) * 10
                        ),
                        life: 1.0,
                        decay: 0.02 + Math.random() * 0.02,
                        size: type === 'exhaust' ? 0.5 : 1 + Math.random() * 2,
                        color: new THREE.Color(color)
                    };
                    this.particles.push(particle);
                }
            }

            update(deltaTime) {
                this.particles = this.particles.filter(p => {
                    p.position.add(p.velocity.clone().multiplyScalar(deltaTime));
                    p.velocity.y -= 5 * deltaTime; // é‡åŠ›
                    p.life -= p.decay;
                    return p.life > 0;
                });

                // é™åˆ¶ç²’å­æ•°é‡
                if (this.particles.length > GAME_CONFIG.MAX_PARTICLES) {
                    this.particles = this.particles.slice(-GAME_CONFIG.MAX_PARTICLES);
                }
            }

            render() {
                // ä½¿ç”¨ç®€å•çš„ç‚¹æ¸²æŸ“
                // åœ¨å®é™…é¡¹ç›®ä¸­å¯ä»¥ä½¿ç”¨BufferGeometryä¼˜åŒ–
            }
        }

        // ==================== ç¢°æ’æ£€æµ‹ç±» ====================
        class CollisionDetection {
            checkCarvsObstacle(car, obstacles) {
                const carBox = new THREE.Box3().setFromObject(car.mesh);

                for (let obs of obstacles) {
                    const obsBox = new THREE.Box3().setFromObject(obs.mesh);
                    if (carBox.intersectsBox(obsBox)) {
                        return { collided: true, obstacle: obs };
                    }
                }
                return { collided: false };
            }

            checkCarvsCar(car1, car2) {
                const dist = car1.position.distanceTo(car2.position);
                const minDist = 2.5;

                if (dist < minDist) {
                    return { collided: true, penetration: minDist - dist };
                }
                return { collided: false };
            }
        }

        // ==================== ä¿å­˜ç³»ç»Ÿç±» ====================
        class SaveSystem {
            constructor() {
                this.saveKey = 'racingGameData_v1';
            }

            saveGame(data) {
                const saveData = {
                    bestTime: data.bestTime,
                    bestScore: data.bestScore,
                    totalRaces: data.totalRaces,
                    timestamp: Date.now()
                };

                try {
                    localStorage.setItem(this.saveKey, JSON.stringify(saveData));
                    console.log('Game saved successfully');
                    return true;
                } catch (e) {
                    console.error('Failed to save game:', e);
                    return false;
                }
            }

            loadGame() {
                try {
                    const savedData = localStorage.getItem(this.saveKey);
                    if (savedData) {
                        return JSON.parse(savedData);
                    }
                } catch (e) {
                    console.error('Failed to load game:', e);
                }

                return {
                    bestTime: Infinity,
                    bestScore: 0,
                    totalRaces: 0
                };
            }
        }

        // ==================== UIç®¡ç†å™¨ ====================
        function updateUI() {
            if (playerCar) {
                const speed = Math.abs(playerCar.physics.velocity);
                document.getElementById('speed').textContent = `${Math.round(speed)} km/h`;

                const minutes = Math.floor(gameState.currentTime / 60);
                const seconds = Math.floor(gameState.currentTime % 60);
                const ms = Math.floor((gameState.currentTime % 1) * 100);
                document.getElementById('time').textContent =
                    `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(ms).padStart(2, '0')}`;

                document.getElementById('lap').textContent = `${gameState.currentLap} / ${GAME_CONFIG.TOTAL_LAPS}`;

                const positionText = ['1st', '2nd', '3rd', '4th', '5th', '6th'][gameState.position - 1];
                document.getElementById('position').textContent = positionText;

                document.getElementById('score').textContent = gameState.score;
            }

            updateMinimap();
        }

        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 200, 200);

            // ç»˜åˆ¶èµ›é“
            ctx.fillStyle = '#444';
            ctx.fillRect(70, 0, 60, 200);

            // ç»˜åˆ¶è½¦é“çº¿
            ctx.strokeStyle = '#666';
            ctx.setLineDash([5, 5]);
            for (let i = 1; i < GAME_CONFIG.LANES; i++) {
                const x = 70 + i * 15;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 200);
                ctx.stroke();
            }
            ctx.setLineDash([]);

            // ç»˜åˆ¶ç©å®¶
            if (playerCar) {
                const playerY = 200 - ((playerCar.position.z % 1000) / 1000) * 200;
                const playerX = 100 + (playerCar.position.x / GAME_CONFIG.TRACK_WIDTH) * 60;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(playerX, playerY, 6, 0, Math.PI * 2);
                ctx.fill();
            }

            // ç»˜åˆ¶AIå¯¹æ‰‹
            ctx.fillStyle = '#00ff00';
            aiOpponents.forEach(ai => {
                const aiY = 200 - ((ai.position.z % 1000) / 1000) * 200;
                const aiX = 100 + (ai.position.x / GAME_CONFIG.TRACK_WIDTH) * 60;
                ctx.beginPath();
                ctx.arc(aiX, aiY, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // ==================== æ¸¸æˆä¸»å¾ªç¯ ====================
        function animate() {
            requestAnimationFrame(animate);

            // å¦‚æœåœºæ™¯è¿˜æ²¡åˆå§‹åŒ–ï¼Œå…ˆä¸æ¸²æŸ“
            if (!scene || !camera || !renderer) {
                return;
            }

            if (gameState.mode !== 'racing') {
                renderer.render(scene, camera);
                return;
            }

            const deltaTime = Math.min(clock.getDelta(), 0.1);

            // æ›´æ–°è®¡æ—¶
            gameState.currentTime += deltaTime;

            // æ›´æ–°ç©å®¶è½¦è¾†
            playerCar.update(deltaTime);

            // å‘å°„å°¾æ°”ç²’å­
            if (inputState.throttle && playerCar.physics.velocity > 10) {
                const exhaustPos = playerCar.position.clone();
                exhaustPos.z -= 2;
                exhaustPos.y = 0.5;
                particleSystem.emit('exhaust', exhaustPos, 1, 0x888888);
            }

            // æ›´æ–°AIå¯¹æ‰‹
            aiOpponents.forEach(ai => {
                ai.update(deltaTime, trackGenerator.getObstacles());
            });

            // æ›´æ–°èµ›é“
            trackGenerator.update(playerCar.position.z);

            // ç¢°æ’æ£€æµ‹
            const collision = collisionDetection.checkCarvsObstacle(playerCar, trackGenerator.getObstacles());
            if (collision.collided) {
                // ç¢°æ’åå‡é€Ÿï¼Œä½†ä¸ä¼šå®Œå…¨åœæ­¢
                playerCar.physics.velocity *= 0.5;
                // ç§»é™¤å·²ç¢°æ’çš„éšœç¢ç‰©ï¼Œé¿å…è¿ç»­ç¢°æ’
                collision.obstacle.active = false;
                trackGenerator.mesh.remove(collision.obstacle.mesh);
                particleSystem.emit('explosion', collision.obstacle.position, 20, 0xff6600);
            }

            // è½¦å¯¹è½¦ç¢°æ’
            aiOpponents.forEach(ai => {
                const carCollision = collisionDetection.checkCarvsCar(playerCar, ai);
                if (carCollision.collided) {
                    playerCar.physics.velocity *= 0.7;
                    ai.physics.velocity *= 0.7;
                }
            });

            // æ›´æ–°ç²’å­ç³»ç»Ÿ
            particleSystem.update(deltaTime);

            // è®¡ç®—æ’å
            const allCars = [playerCar, ...aiOpponents];
            allCars.sort((a, b) => b.position.z - a.position.z);
            gameState.position = allCars.indexOf(playerCar) + 1;

            // æ£€æŸ¥åœˆæ•°
            if (playerCar.position.z >= gameState.currentLap * GAME_CONFIG.TRACK_LENGTH) {
                gameState.currentLap++;

                if (gameState.currentLap > GAME_CONFIG.TOTAL_LAPS) {
                    endRace();
                }
            }

            // æ›´æ–°ç›¸æœº
            const cameraOffset = new THREE.Vector3(0, 8, -15);
            const targetPos = playerCar.position.clone().add(cameraOffset);
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(playerCar.position);

            // æ¸²æŸ“
            renderer.render(scene, camera);

            // æ›´æ–°UI
            updateUI();
        }

        // ==================== æ¸¸æˆæ§åˆ¶å‡½æ•° ====================
        function init() {
            // åŠ è½½ä¿å­˜æ•°æ®
            saveSystem = new SaveSystem();
            const savedData = saveSystem.loadGame();
            gameState.bestTime = savedData.bestTime;
            gameState.bestScore = savedData.bestScore;
            gameState.totalRaces = savedData.totalRaces;

            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 500);

            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, -20);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('game-container').appendChild(renderer.domElement);

            // æ·»åŠ å…‰ç…§
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.0);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // åˆ›å»ºæ¸¸æˆå¯¹è±¡
            trackGenerator = new TrackGenerator();
            scene.add(trackGenerator.mesh);

            playerCar = new Car(0xff0000, true);
            playerCar.position.set(0, 0, 0);
            scene.add(playerCar.mesh);

            for (let i = 0; i < GAME_CONFIG.AI_COUNT; i++) {
                const ai = new AIOpponent(i, 0.7);
                aiOpponents.push(ai);
                scene.add(ai.mesh);
            }

            particleSystem = new ParticleSystem();
            collisionDetection = new CollisionDetection();

            // è®¾ç½®è¾“å…¥ç›‘å¬
            setupInput();

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }

        function setupInput() {
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        inputState.throttle = true;
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        inputState.brake = true;
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        inputState.steering = 1;
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        inputState.steering = -1;
                        break;
                    case ' ':
                        inputState.handbrake = true;
                        e.preventDefault();
                        break;
                    case 'p':
                    case 'P':
                        if (gameState.mode === 'racing') {
                            pauseGame();
                        } else if (gameState.mode === 'paused') {
                            resumeGame();
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch(e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        inputState.throttle = false;
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        inputState.brake = false;
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        inputState.steering = 0;
                        break;
                    case ' ':
                        inputState.handbrake = false;
                        break;
                }
            });
        }

        function startGame() {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('hud').classList.remove('hidden');
            document.getElementById('minimap-container').classList.remove('hidden');
            document.getElementById('controls').classList.remove('hidden');

            gameState.mode = 'racing';
            gameState.currentTime = 0;
            gameState.currentLap = 1;
            gameState.score = 0;

            // é‡ç½®è½¦è¾†ä½ç½®
            playerCar.position.set(0, 0, 0);
            playerCar.physics.velocity = 0;

            aiOpponents.forEach((ai, i) => {
                const laneX = (i - 1.5) * GAME_CONFIG.LANE_WIDTH;
                ai.position.set(laneX, 0, -10 - i * 5);
                ai.physics.velocity = 0;
                ai.mesh.position.copy(ai.position);
            });

            trackGenerator.reset();
            clock.start();
        }

        function pauseGame() {
            gameState.mode = 'paused';
            document.getElementById('pause-menu').style.display = 'block';
        }

        function resumeGame() {
            gameState.mode = 'racing';
            document.getElementById('pause-menu').style.display = 'none';
        }

        function endRace() {
            gameState.mode = 'gameover';

            // è®¡ç®—å¾—åˆ†
            const timeBonus = Math.max(0, 1000 - gameState.currentTime);
            const positionBonus = (6 - gameState.position) * 500;
            gameState.score = Math.round(timeBonus + positionBonus);

            // æ›´æ–°æœ€ä½³æˆç»©
            let newRecord = false;
            if (gameState.currentTime < gameState.bestTime) {
                gameState.bestTime = gameState.currentTime;
                newRecord = true;
            }

            if (gameState.score > gameState.bestScore) {
                gameState.bestScore = gameState.score;
                newRecord = true;
            }

            gameState.totalRaces++;

            // ä¿å­˜è¿›åº¦
            saveSystem.saveGame(gameState);

            // æ˜¾ç¤ºç»“æœ
            const positionText = ['1st', '2nd', '3rd', '4th', '5th', '6th'][gameState.position - 1];
            document.getElementById('final-position').textContent = positionText;

            const minutes = Math.floor(gameState.currentTime / 60);
            const seconds = Math.floor(gameState.currentTime % 60);
            const ms = Math.floor((gameState.currentTime % 1) * 100);
            document.getElementById('final-time').textContent =
                `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(ms).padStart(2, '0')}`;

            document.getElementById('final-score').textContent = gameState.score;

            if (newRecord) {
                document.getElementById('best-record').textContent = 'ğŸ† æ–°çºªå½•ï¼';
            } else {
                document.getElementById('best-record').textContent = '';
            }

            document.getElementById('game-over').style.display = 'block';
        }

        function restartGame() {
            document.getElementById('game-over').style.display = 'none';
            startGame();
        }

        function quitToMenu() {
            document.getElementById('pause-menu').style.display = 'none';
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('hud').classList.add('hidden');
            document.getElementById('minimap-container').classList.add('hidden');
            document.getElementById('controls').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
            gameState.mode = 'menu';
        }

        // ==================== åˆå§‹åŒ– ====================
        window.addEventListener('load', init);
    </script>
</body>
</html>
